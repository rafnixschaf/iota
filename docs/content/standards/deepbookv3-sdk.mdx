---
title: DeepBookV3 SDK
---

The DeepBook typescript SDK abstracts away the transaction calls, allowing for direct interactions with the DeepBook package. To use the SDK in your projects, install the `@iota/deepbook` package.

```sh npm2yarn
npm install @iota/deepbook-v3
```

## Constants

The DeepBookV3 SDK includes a constants file (`/utils/constants.ts`) that maintains the latest deployed addresses for DeepBook, as well as a few staple coins and pools. 

<details>
<summary>
Toggle constants.ts code
</summary>
{@inject: sdk/deepbook/src/utils/constants.ts}
</details>

## DeepBookClient

To work with DeepBook, you must create a `DeepBookClient`. To construct the `DeepBookClient`, pass in a `IotaClient`, the sender address, and environment. The [Iota TypeScript SDK](https://wiki.iota.org/references/ts-sdk/typescript) provides the `IotaClient` and key functionality necessary to process transactions. The following example imports those libraries, as well. 

```tsx
import { IotaClient, getFullnodeUrl } from "@iota/iota/client";
import { Ed25519Keypair } from "@iota/iota/keypairs/ed25519";
import { decodeIotaPrivateKey } from "@iota/iota/cryptography";

import { DeepBookClient } from "@iota/deepbook";

class DeepBookMarketMaker {
    dbClient: DeepBookClient; // For building transactions
    iotaClient: IotaClient; // For executing transactions
    keypair: Ed25519Keypair; // For signing transactions

    constructor(privateKey: string, env: 'testnet' | 'mainnet') {
        this.keypair = this.getSignerFromPK(privateKey);
        this.iotaClient = new IotaClient({
            url: getFullnodeUrl(env)
        })
        this.dbClient = new DeepBookClient({
            address: this.getActiveAddress(),
            env: env,
            client: this.iotaClient,
        });
    }

    getSignerFromPK = (privateKey: string): Ed25519Keypair => {
      const { schema, secretKey } = decodeIotaPrivateKey(privateKey);
      if (schema === 'ED25519') return Ed25519Keypair.fromSecretKey(secretKey);
  
      throw new Error(`Unsupported schema: ${schema}`);
    };

    getActiveAddress() {
        return this.keypair.toIotaAddress();
    }
}
```

## Keys: Coin, Pool, and Manager {#keys}

Functions that require the input of a coin, pool, or a manager require the key of any such object as the parameter. The SDK manages a key:value relationship of this data in memory. Some default data comes with the SDK (as seen in `utils/constants.ts`). Coins are stored in a `CoinMap` and pools in a `PoolMap` in the config.

### Balance manager

Before placing any trade, you must supply a balance manager address to the client. The manager key points to an object defined by the `BalanceManager` interface in the client. [BalanceManager docs](./deepbookv3/balance-manager.mdx). Initialize the balance manager with the client. If you don't create a balance manager, you can rely on the client to create one, but then the user must reinitialize the client.

Example using an existing balance manager:
    
```tsx
import { IotaClient, getFullnodeUrl } from "@iota/iota/client";
import { Ed25519Keypair } from "@iota/iota/keypairs/ed25519";
import { decodeIotaPrivateKey } from "@iota/iota/cryptography";
import { config } from 'dotenv';
config();

import { DeepBookClient } from "../src";
import { BalanceManager } from "./types";

// Used wherever balance manager key is required
const BALANCE_MANAGER_KEY = 'MANAGER_1';

class DeepBookMarketMaker {
    dbClient: DeepBookClient; // For building transactions
    iotaClient: IotaClient; // For executing transactions
    keypair: Ed25519Keypair; // For signing transactions
    env: 'testnet' | 'mainnet';

    constructor(privateKey: string, env: 'testnet' | 'mainnet') {
        this.env = env;
        this.keypair = this.getSignerFromPK(privateKey);
        this.iotaClient = new IotaClient({
            url: getFullnodeUrl(env)
        })
        this.dbClient = new DeepBookClient({
            address: this.getActiveAddress(),
            env: env,
            client: this.iotaClient,
            balanceManagers: this.getBalanceManagers()
        });
    }

    getSignerFromPK = (privateKey: string): Ed25519Keypair => {
    const { schema, secretKey } = decodeIotaPrivateKey(privateKey);
    if (schema === 'ED25519') return Ed25519Keypair.fromSecretKey(secretKey);

    throw new Error(`Unsupported schema: ${schema}`);
  };

    getActiveAddress() {
        return this.keypair.toIotaAddress();
    }

    getBalanceManagers(): { [key: string]: BalanceManager } {
        // Used wherever balance manager key is required
        const balanceManagerAddress = process.env.BALANCE_MANAGER_ADDRESS;
        const balanceManagerTradeCap = process.env.BALANCE_MANAGER_TRADE_CAP;
        if (!balanceManagerAddress) {
            throw new Error('No balance manager address found');
        }
        return {
            BALANCE_MANAGER_KEY: {
                address: balanceManagerAddress,
                tradeCap: balanceManagerTradeCap
            }
        }
    }
}
```
    
Example creating a balance manager:
    
```tsx
import { IotaClient, getFullnodeUrl } from "@iota/iota/client";
import { Ed25519Keypair } from "@iota/iota/keypairs/ed25519";
import { decodeIotaPrivateKey } from "@iota/iota/cryptography";

import { DeepBookClient } from "../src";
import { Transaction } from "@iota/iota/transactions";
import { BalanceManager } from "./types";

// Used wherever balance manager key is required
const BALANCE_MANAGER_KEY = 'MANAGER_1';

class DeepBookMarketMaker {
    dbClient: DeepBookClient; // For building transactions
    iotaClient: IotaClient; // For executing transactions
    keypair: Ed25519Keypair; // For signing transactions
    env: 'testnet' | 'mainnet';

    constructor(privateKey: string, env: 'testnet' | 'mainnet') {
        this.env = env;
        this.keypair = this.getSignerFromPK(privateKey);
        this.iotaClient = new IotaClient({
            url: getFullnodeUrl(env)
        })
        this.dbClient = new DeepBookClient({
            address: this.getActiveAddress(),
            env: env,
            client: this.iotaClient,
        });
    }

    getSignerFromPK = (privateKey: string): Ed25519Keypair => {
      const { schema, secretKey } = decodeIotaPrivateKey(privateKey);
      if (schema === 'ED25519') return Ed25519Keypair.fromSecretKey(secretKey);
  
      throw new Error(`Unsupported schema: ${schema}`);
    };

    getActiveAddress() {
        return this.keypair.toIotaAddress();
    }

    async createBalanceManagerAndReinitialize() {
        let tx = new Transaction();
        tx.add(this.dbClient.balanceManager.createAndShareBalanceManager());
        
        const res = await this.iotaClient.signAndExecuteTransaction({
            transaction: tx,
            signer: this.keypair,
            options: {
                showEffects: true,
                showObjectChanges: true,
            },
        })

        // @ts-ignore
        const balanceManagerAddress = res.objectChanges?.find((change) => {
            change.type === 'created' && change.objectType.includes('BalanceManager');
        })?.['objectId'];

        const balanceManagers: { [key: string]: BalanceManager } = {
            BALANCE_MANAGER_KEY: {
                address: balanceManagerAddress,
                tradeCap: undefined,
            }
        }

        this.dbClient = new DeepBookClient({
            address: this.getActiveAddress(),
            env: this.env,
            client: this.iotaClient,
            balanceManagers: balanceManagers,
        })
    }
}
```

### Coin

The SDK comes with four default coins on Testnet and five default coins on Mainnet. 

**Default Testnet coins**
- DEEP
- IOTA
- DBUSDC
- DBUSDT

**Default Mainnet coins**
- DEEP
- IOTA
- USDC
- USDT
- WETH

You can also initialize the SDK with custom coins to interact with pools that are not supported by default. To do this, create a `CoinMap` object and pass it to the constructor of the client.

### Pool

Similar to coins, the SDK comes with default pools. You can provide a `PoolMap` during construction to override this behavior.
    
```tsx
import { decodeIotaPrivateKey } from '@iota/iota-sdk/cryptography';
import { getFullnodeUrl, IotaClient } from '@iota/iota/client';
import type { Keypair } from '@iota/iota/cryptography';
import { Ed25519Keypair } from '@iota/iota/keypairs/ed25519';
import type { Transaction } from '@iota/iota/transactions';

import { DeepBookClient } from '../src/index.js'; // Adjust path according to new structure
import type { BalanceManager } from '../src/types/index.js';

export class DeepBookMarketMaker extends DeepBookClient {
  keypair: Keypair;
  iotaClient: IotaClient;

  constructor(
    keypair: string | Keypair,
    env: 'testnet' | 'mainnet',
    balanceManagers?: { [key: string]: BalanceManager },
    adminCap?: string,
  ) {
    let resolvedKeypair: Keypair;

    if (typeof keypair === 'string') {
      resolvedKeypair = DeepBookMarketMaker.#getSignerFromPK(keypair);
    } else {
      resolvedKeypair = keypair;
    }

    const address = resolvedKeypair.toIotaAddress();

    super({
      address: address,
      env: env,
      client: new IotaClient({
        url: getFullnodeUrl(env),
      }),
      balanceManagers: balanceManagers,
      adminCap: adminCap,
    });

    this.keypair = resolvedKeypair;
    this.iotaClient = new IotaClient({
      url: getFullnodeUrl(env),
    });
  }

  static #getSignerFromPK = (privateKey: string) => {
    const { schema, secretKey } = decodeIotaPrivateKey(privateKey);
    if (schema === 'ED25519') return Ed25519Keypair.fromSecretKey(secretKey);

    throw new Error(`Unsupported schema: ${schema}`);
  };

  signAndExecute = async (tx: Transaction) => {
    // remove arguments
    return this.iotaClient.signAndExecuteTransaction({
      transaction: tx,
      signer: this.keypair,
      options: {
        showEffects: true,
        showObjectChanges: true,
      },
    });
  };

  getActiveAddress() {
    return this.keypair.getPublicKey().toIotaAddress();
  }
}

```

### Example setup

The following example uses the default pools and coins provided.
    
```tsx
import { Transaction } from '@iota/iota/transactions';
import { DeepBookMarketMaker } from './deepbookMarketMaker.js';

(async () => {
  const privateKey = ''; // Can encapsalate this in a .env file

  // Initialize with balance managers if created
  const balanceManagers = {
    MANAGER_1: {
      address: '',
      tradeCap: '',
    },
  };
  const mmClient = new DeepBookMarketMaker(
    privateKey,
    'testnet',
    balanceManagers,
  );

  const tx = new Transaction();

  // Read only call
  console.log(await mmClient.checkManagerBalance('MANAGER_1', 'IOTA'));
  console.log(await mmClient.getLevel2Range('IOTA_DBUSDC', 0.1, 100, true));

  // Balance manager contract call
  mmClient.balanceManager.depositIntoManager('MANAGER_1', 'DBUSDT', 10000)(tx);
  mmClient.balanceManager.withdrawAllFromManager(
    'MANAGER_1',
    'DBUSDT',
    mmClient.getActiveAddress(),
  )(tx);

  // Example custom PTB call in DeepBookMarketMaker class
  mmClient.placeLimitOrderExample(tx);
  mmClient.flashLoanExample(tx);

  let res = await mmClient.signAndExecute(tx);

  console.dir(res, { depth: null });
})();

```