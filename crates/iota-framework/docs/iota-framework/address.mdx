---
title: Module `0x2::address`
---
import Link from '@docusaurus/Link';

<Link id="0x2_address"/>


-  [Constants](#@Constants_0)
-  [Function `to_u256`](#0x2_address_to_u256)
-  [Function `from_u256`](#0x2_address_from_u256)
-  [Function `from_bytes`](#0x2_address_from_bytes)
-  [Function `to_bytes`](#0x2_address_to_bytes)
-  [Function `to_ascii_string`](#0x2_address_to_ascii_string)
-  [Function `to_string`](#0x2_address_to_string)
-  [Function `from_ascii_bytes`](#0x2_address_from_ascii_bytes)
-  [Function `hex_char_value`](#0x2_address_hex_char_value)
-  [Function `length`](#0x2_address_length)
-  [Function `max`](#0x2_address_max)


<pre><code>
<b>use</b> <Link to="../move-stdlib/ascii#0x1_ascii">0x1::ascii</Link>;
<b>use</b> <Link to="../move-stdlib/bcs#0x1_bcs">0x1::bcs</Link>;
<b>use</b> <Link to="../move-stdlib/string#0x1_string">0x1::string</Link>;
<b>use</b> <Link to="../iota-framework/hex#0x2_hex">0x2::hex</Link>;
</code></pre>



<Link id="@Constants_0"></Link>

## Constants


<Link id="0x2_address_EAddressParseError"></Link>

Error from <code>
from_bytes</code> when it is supplied too many or too few bytes.


<pre><code>
<b>const</b> <Link to="../iota-framework/address#0x2_address_EAddressParseError">EAddressParseError</Link>: u64 = 0;
</code></pre>



<Link id="0x2_address_LENGTH"></Link>

The length of an address, in bytes


<pre><code>
<b>const</b> <Link to="../iota-framework/address#0x2_address_LENGTH">LENGTH</Link>: u64 = 32;
</code></pre>



<Link id="0x2_address_MAX"></Link>



<pre><code>
<b>const</b> <Link to="../iota-framework/address#0x2_address_MAX">MAX</Link>: u256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935;
</code></pre>



<Link id="0x2_address_to_u256"></Link>

## Function `to_u256`

Convert <code>
a</code> into a u256 by interpreting <code>
a</code> as the bytes of a big-endian integer
(e.g., <code>
<Link to="../iota-framework/address#0x2_address_to_u256">to_u256</Link>(0x1) == 1</code>)


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/address#0x2_address_to_u256">to_u256</Link>(a: <b>address</b>): u256
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>native</b> <b>fun</b> <Link to="../iota-framework/address#0x2_address_to_u256">to_u256</Link>(a: <b>address</b>): u256;
</code></pre>



</details>

<Link id="0x2_address_from_u256"></Link>

## Function `from_u256`

Convert <code>
n</code> into an address by encoding it as a big-endian integer (e.g., <code>
<Link to="../iota-framework/address#0x2_address_from_u256">from_u256</Link>(1) = @0x1</code>)
Aborts if <code>
n</code> > <code>
MAX_ADDRESS</code>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/address#0x2_address_from_u256">from_u256</Link>(n: u256): <b>address</b>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>native</b> <b>fun</b> <Link to="../iota-framework/address#0x2_address_from_u256">from_u256</Link>(n: u256): <b>address</b>;
</code></pre>



</details>

<Link id="0x2_address_from_bytes"></Link>

## Function `from_bytes`

Convert <code>
bytes</code> into an address.
Aborts with <code>
<Link to="../iota-framework/address#0x2_address_EAddressParseError">EAddressParseError</Link></code> if the length of <code>
bytes</code> is not 32


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/address#0x2_address_from_bytes">from_bytes</Link>(bytes: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;): <b>address</b>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>native</b> <b>fun</b> <Link to="../iota-framework/address#0x2_address_from_bytes">from_bytes</Link>(bytes: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;): <b>address</b>;
</code></pre>



</details>

<Link id="0x2_address_to_bytes"></Link>

## Function `to_bytes`

Convert <code>
a</code> into BCS-encoded bytes.


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/address#0x2_address_to_bytes">to_bytes</Link>(a: <b>address</b>): <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/address#0x2_address_to_bytes">to_bytes</Link>(a: <b>address</b>): <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt; \{
    <Link to="../move-stdlib/bcs#0x1_bcs_to_bytes">bcs::to_bytes</Link>(&a)
}
</code></pre>



</details>

<Link id="0x2_address_to_ascii_string"></Link>

## Function `to_ascii_string`

Convert <code>
a</code> to a hex-encoded ASCII string


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/address#0x2_address_to_ascii_string">to_ascii_string</Link>(a: <b>address</b>): <Link to="../move-stdlib/ascii#0x1_ascii_String">ascii::String</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/address#0x2_address_to_ascii_string">to_ascii_string</Link>(a: <b>address</b>): <Link to="../move-stdlib/ascii#0x1_ascii_String">ascii::String</Link> \{
    <Link to="../iota-framework/hex#0x2_hex_encode">hex::encode</Link>(<Link to="../iota-framework/address#0x2_address_to_bytes">to_bytes</Link>(a)).<Link to="../iota-framework/address#0x2_address_to_ascii_string">to_ascii_string</Link>()
}
</code></pre>



</details>

<Link id="0x2_address_to_string"></Link>

## Function `to_string`

Convert <code>
a</code> to a hex-encoded string


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/address#0x2_address_to_string">to_string</Link>(a: <b>address</b>): <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/address#0x2_address_to_string">to_string</Link>(a: <b>address</b>): <Link to="../move-stdlib/string#0x1_string_String">string::String</Link> \{
    <Link to="../iota-framework/address#0x2_address_to_ascii_string">to_ascii_string</Link>(a).<Link to="../iota-framework/address#0x2_address_to_string">to_string</Link>()
}
</code></pre>



</details>

<Link id="0x2_address_from_ascii_bytes"></Link>

## Function `from_ascii_bytes`

Converts an ASCII string to an address, taking the numerical value for each character. The
string must be Base16 encoded, and thus exactly 64 characters long.
For example, the string "00000000000000000000000000000000000000000000000000000000DEADB33F"
will be converted to the address @0xDEADB33F.
Aborts with <code>
<Link to="../iota-framework/address#0x2_address_EAddressParseError">EAddressParseError</Link></code> if the length of <code>
s</code> is not 64,
or if an invalid character is encountered.


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/address#0x2_address_from_ascii_bytes">from_ascii_bytes</Link>(bytes: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;): <b>address</b>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/address#0x2_address_from_ascii_bytes">from_ascii_bytes</Link>(bytes: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;): <b>address</b> \{
    <b>assert</b>!(bytes.<Link to="../iota-framework/address#0x2_address_length">length</Link>() == 64, <Link to="../iota-framework/address#0x2_address_EAddressParseError">EAddressParseError</Link>);
    <b>let</b> <b>mut</b> hex_bytes = <Link to="../move-stdlib/vector#0x1_vector">vector</Link>[];
    <b>let</b> <b>mut</b> i = 0;
    <b>while</b> (i &lt; 64) \{
        <b>let</b> hi = <Link to="../iota-framework/address#0x2_address_hex_char_value">hex_char_value</Link>(bytes[i]);
        <b>let</b> lo = <Link to="../iota-framework/address#0x2_address_hex_char_value">hex_char_value</Link>(bytes[i+1]);
        hex_bytes.push_back((hi &lt;&lt; 4) | lo);
        i = i + 2;
    };
    <Link to="../iota-framework/address#0x2_address_from_bytes">from_bytes</Link>(hex_bytes)
}
</code></pre>



</details>

<Link id="0x2_address_hex_char_value"></Link>

## Function `hex_char_value`



<pre><code>
<b>fun</b> <Link to="../iota-framework/address#0x2_address_hex_char_value">hex_char_value</Link>(c: u8): u8
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="../iota-framework/address#0x2_address_hex_char_value">hex_char_value</Link>(c: u8): u8 \{
    <b>if</b> (c &gt;= 48 && c &lt;= 57) c - 48 // 0-9
    <b>else</b> <b>if</b> (c &gt;= 65 && c &lt;= 70) c - 55 // A-F
    <b>else</b> <b>if</b> (c &gt;= 97 && c &lt;= 102) c - 87 // a-f
    <b>else</b> <b>abort</b> <Link to="../iota-framework/address#0x2_address_EAddressParseError">EAddressParseError</Link>
}
</code></pre>



</details>

<Link id="0x2_address_length"></Link>

## Function `length`

Length of a Iota address in bytes


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/address#0x2_address_length">length</Link>(): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/address#0x2_address_length">length</Link>(): u64 \{
    <Link to="../iota-framework/address#0x2_address_LENGTH">LENGTH</Link>
}
</code></pre>



</details>

<Link id="0x2_address_max"></Link>

## Function `max`

Largest possible address


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/address#0x2_address_max">max</Link>(): u256
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/address#0x2_address_max">max</Link>(): u256 \{
    <Link to="../iota-framework/address#0x2_address_MAX">MAX</Link>
}
</code></pre>



</details>
