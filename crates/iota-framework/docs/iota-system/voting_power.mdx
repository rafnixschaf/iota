---
title: Module `0x3::voting_power`
---
import Link from '@docusaurus/Link';

<Link id="0x3_voting_power"/>


-  [Struct `VotingPowerInfo`](#0x3_voting_power_VotingPowerInfo)
-  [Struct `VotingPowerInfoV2`](#0x3_voting_power_VotingPowerInfoV2)
-  [Constants](#@Constants_0)
-  [Function `set_voting_power`](#0x3_voting_power_set_voting_power)
-  [Function `init_voting_power_info`](#0x3_voting_power_init_voting_power_info)
-  [Function `total_stake`](#0x3_voting_power_total_stake)
-  [Function `insert`](#0x3_voting_power_insert)
-  [Function `adjust_voting_power`](#0x3_voting_power_adjust_voting_power)
-  [Function `update_voting_power`](#0x3_voting_power_update_voting_power)
-  [Function `check_invariants`](#0x3_voting_power_check_invariants)
-  [Function `total_voting_power`](#0x3_voting_power_total_voting_power)
-  [Function `quorum_threshold`](#0x3_voting_power_quorum_threshold)


<pre><code>
<b>use</b> <Link to="../move-stdlib/vector#0x1_vector">0x1::vector</Link>;
<b>use</b> <Link to="../iota-framework/math#0x2_math">0x2::math</Link>;
<b>use</b> <Link to="validator#0x3_validator">0x3::validator</Link>;
</code></pre>



<Link id="0x3_voting_power_VotingPowerInfo"></Link>

## Struct `VotingPowerInfo`

Deprecated. Use VotingPowerInfoV2 instead.


<pre><code>
<b>struct</b> <Link to="voting_power#0x3_voting_power_VotingPowerInfo">VotingPowerInfo</Link> <b>has</b> drop
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
validator_index: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
<Link to="voting_power#0x3_voting_power">voting_power</Link>: u64</code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0x3_voting_power_VotingPowerInfoV2"></Link>

## Struct `VotingPowerInfoV2`



<pre><code>
<b>struct</b> <Link to="voting_power#0x3_voting_power_VotingPowerInfoV2">VotingPowerInfoV2</Link> <b>has</b> drop
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
validator_index: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
<Link to="voting_power#0x3_voting_power">voting_power</Link>: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
stake: u64</code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="@Constants_0"></Link>

## Constants


<Link id="0x3_voting_power_EInvalidVotingPower"></Link>



<pre><code>
<b>const</b> <Link to="voting_power#0x3_voting_power_EInvalidVotingPower">EInvalidVotingPower</Link>: u64 = 4;
</code></pre>



<Link id="0x3_voting_power_ERelativePowerMismatch"></Link>



<pre><code>
<b>const</b> <Link to="voting_power#0x3_voting_power_ERelativePowerMismatch">ERelativePowerMismatch</Link>: u64 = 2;
</code></pre>



<Link id="0x3_voting_power_ETotalPowerMismatch"></Link>



<pre><code>
<b>const</b> <Link to="voting_power#0x3_voting_power_ETotalPowerMismatch">ETotalPowerMismatch</Link>: u64 = 1;
</code></pre>



<Link id="0x3_voting_power_EVotingPowerOverThreshold"></Link>



<pre><code>
<b>const</b> <Link to="voting_power#0x3_voting_power_EVotingPowerOverThreshold">EVotingPowerOverThreshold</Link>: u64 = 3;
</code></pre>



<Link id="0x3_voting_power_MAX_VOTING_POWER"></Link>



<pre><code>
<b>const</b> <Link to="voting_power#0x3_voting_power_MAX_VOTING_POWER">MAX_VOTING_POWER</Link>: u64 = 1000;
</code></pre>



<Link id="0x3_voting_power_QUORUM_THRESHOLD"></Link>

Quorum threshold for our fixed voting power--any message signed by this much voting power can be trusted
up to BFT assumptions


<pre><code>
<b>const</b> <Link to="voting_power#0x3_voting_power_QUORUM_THRESHOLD">QUORUM_THRESHOLD</Link>: u64 = 6667;
</code></pre>



<Link id="0x3_voting_power_TOTAL_VOTING_POWER"></Link>

Set total_voting_power as 10_000 by convention. Individual voting powers can be interpreted
as easily understandable basis points (e.g., voting_power: 100 = 1%, voting_power: 1 = 0.01%) rather than
opaque quantities whose meaning changes from epoch to epoch as the total amount staked shifts.
Fixing the total voting power allows clients to hardcode the quorum threshold and total_voting power rather
than recomputing these.


<pre><code>
<b>const</b> <Link to="voting_power#0x3_voting_power_TOTAL_VOTING_POWER">TOTAL_VOTING_POWER</Link>: u64 = 10000;
</code></pre>



<Link id="0x3_voting_power_set_voting_power"></Link>

## Function `set_voting_power`

Set the voting power of all validators.
Each validator's voting power is initialized using their stake. We then attempt to cap their voting power
at <code>
<Link to="voting_power#0x3_voting_power_MAX_VOTING_POWER">MAX_VOTING_POWER</Link></code>. If <code>
<Link to="voting_power#0x3_voting_power_MAX_VOTING_POWER">MAX_VOTING_POWER</Link></code> is not a feasible cap, we pick the lowest possible cap.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="voting_power#0x3_voting_power_set_voting_power">set_voting_power</Link>(validators: &<b>mut</b> <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="voting_power#0x3_voting_power_set_voting_power">set_voting_power</Link>(validators: &<b>mut</b> <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;) \{
    // If threshold_pct is too small, it's possible that even when all validators reach the threshold we still don't
    // have 100%. So we bound the threshold_pct <b>to</b> be always enough <b>to</b> find a solution.
    <b>let</b> threshold = <Link to="../iota-framework/math#0x2_math_min">math::min</Link>(
        <Link to="voting_power#0x3_voting_power_TOTAL_VOTING_POWER">TOTAL_VOTING_POWER</Link>,
        <Link to="../iota-framework/math#0x2_math_max">math::max</Link>(<Link to="voting_power#0x3_voting_power_MAX_VOTING_POWER">MAX_VOTING_POWER</Link>, divide_and_round_up(<Link to="voting_power#0x3_voting_power_TOTAL_VOTING_POWER">TOTAL_VOTING_POWER</Link>, validators.length())),
    );
    <b>let</b> (<b>mut</b> info_list, remaining_power) = <Link to="voting_power#0x3_voting_power_init_voting_power_info">init_voting_power_info</Link>(validators, threshold);
    <Link to="voting_power#0x3_voting_power_adjust_voting_power">adjust_voting_power</Link>(&<b>mut</b> info_list, threshold, remaining_power);
    <Link to="voting_power#0x3_voting_power_update_voting_power">update_voting_power</Link>(validators, info_list);
    <Link to="voting_power#0x3_voting_power_check_invariants">check_invariants</Link>(validators);
}
</code></pre>



</details>

<Link id="0x3_voting_power_init_voting_power_info"></Link>

## Function `init_voting_power_info`

Create the initial voting power of each validator, set using their stake, but capped using threshold.
We also perform insertion sort while creating the voting power list, by maintaining the list in
descending order using voting power.
Anything beyond the threshold is added to the remaining_power, which is also returned.


<pre><code>
<b>fun</b> <Link to="voting_power#0x3_voting_power_init_voting_power_info">init_voting_power_info</Link>(validators: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;, threshold: u64): (<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="voting_power#0x3_voting_power_VotingPowerInfoV2">voting_power::VotingPowerInfoV2</Link>&gt;, u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="voting_power#0x3_voting_power_init_voting_power_info">init_voting_power_info</Link>(
    validators: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;,
    threshold: u64,
): (<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="voting_power#0x3_voting_power_VotingPowerInfoV2">VotingPowerInfoV2</Link>&gt;, u64) \{
    <b>let</b> total_stake = <Link to="voting_power#0x3_voting_power_total_stake">total_stake</Link>(validators);
    <b>let</b> <b>mut</b> i = 0;
    <b>let</b> len = validators.length();
    <b>let</b> <b>mut</b> total_power = 0;
    <b>let</b> <b>mut</b> result = <Link to="../move-stdlib/vector#0x1_vector">vector</Link>[];
    <b>while</b> (i &lt; len) \{
        <b>let</b> <Link to="validator#0x3_validator">validator</Link> = &validators[i];
        <b>let</b> stake = <Link to="validator#0x3_validator">validator</Link>.<Link to="voting_power#0x3_voting_power_total_stake">total_stake</Link>();
        <b>let</b> adjusted_stake = stake <b>as</b> u128 * (<Link to="voting_power#0x3_voting_power_TOTAL_VOTING_POWER">TOTAL_VOTING_POWER</Link> <b>as</b> u128) / (total_stake <b>as</b> u128);
        <b>let</b> <Link to="voting_power#0x3_voting_power">voting_power</Link> = <Link to="../iota-framework/math#0x2_math_min">math::min</Link>(adjusted_stake <b>as</b> u64, threshold);
        <b>let</b> info = <Link to="voting_power#0x3_voting_power_VotingPowerInfoV2">VotingPowerInfoV2</Link> \{
            validator_index: i,
            <Link to="voting_power#0x3_voting_power">voting_power</Link>,
            stake,
        };
        <Link to="voting_power#0x3_voting_power_insert">insert</Link>(&<b>mut</b> result, info);
        total_power = total_power + <Link to="voting_power#0x3_voting_power">voting_power</Link>;
        i = i + 1;
    };
    (result, <Link to="voting_power#0x3_voting_power_TOTAL_VOTING_POWER">TOTAL_VOTING_POWER</Link> - total_power)
}
</code></pre>



</details>

<Link id="0x3_voting_power_total_stake"></Link>

## Function `total_stake`

Sum up the total stake of all validators.


<pre><code>
<b>fun</b> <Link to="voting_power#0x3_voting_power_total_stake">total_stake</Link>(validators: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="voting_power#0x3_voting_power_total_stake">total_stake</Link>(validators: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;): u64 \{
    <b>let</b> <b>mut</b> i = 0;
    <b>let</b> len = validators.length();
    <b>let</b> <b>mut</b> total_stake =0 ;
    <b>while</b> (i &lt; len) \{
        total_stake = total_stake + validators[i].<Link to="voting_power#0x3_voting_power_total_stake">total_stake</Link>();
        i = i + 1;
    };
    total_stake
}
</code></pre>



</details>

<Link id="0x3_voting_power_insert"></Link>

## Function `insert`

Insert <code>
new_info</code> to <code>
info_list</code> as part of insertion sort, such that <code>
info_list</code> is always sorted
using stake, in descending order.


<pre><code>
<b>fun</b> <Link to="voting_power#0x3_voting_power_insert">insert</Link>(info_list: &<b>mut</b> <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="voting_power#0x3_voting_power_VotingPowerInfoV2">voting_power::VotingPowerInfoV2</Link>&gt;, new_info: <Link to="voting_power#0x3_voting_power_VotingPowerInfoV2">voting_power::VotingPowerInfoV2</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="voting_power#0x3_voting_power_insert">insert</Link>(info_list: &<b>mut</b> <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="voting_power#0x3_voting_power_VotingPowerInfoV2">VotingPowerInfoV2</Link>&gt;, new_info: <Link to="voting_power#0x3_voting_power_VotingPowerInfoV2">VotingPowerInfoV2</Link>) \{
    <b>let</b> <b>mut</b> i = 0;
    <b>let</b> len = info_list.length();
    <b>while</b> (i &lt; len && info_list[i].stake &gt; new_info.stake) \{
        i = i + 1;
    };
    info_list.<Link to="voting_power#0x3_voting_power_insert">insert</Link>(new_info, i);
}
</code></pre>



</details>

<Link id="0x3_voting_power_adjust_voting_power"></Link>

## Function `adjust_voting_power`

Distribute remaining_power to validators that are not capped at threshold.


<pre><code>
<b>fun</b> <Link to="voting_power#0x3_voting_power_adjust_voting_power">adjust_voting_power</Link>(info_list: &<b>mut</b> <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="voting_power#0x3_voting_power_VotingPowerInfoV2">voting_power::VotingPowerInfoV2</Link>&gt;, threshold: u64, remaining_power: u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="voting_power#0x3_voting_power_adjust_voting_power">adjust_voting_power</Link>(info_list: &<b>mut</b> <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="voting_power#0x3_voting_power_VotingPowerInfoV2">VotingPowerInfoV2</Link>&gt;, threshold: u64, <b>mut</b> remaining_power: u64) \{
    <b>let</b> <b>mut</b> i = 0;
    <b>let</b> len = info_list.length();
    <b>while</b> (i &lt; len && remaining_power &gt; 0) \{
        <b>let</b> v = &<b>mut</b> info_list[i];
        // planned is the amount of extra power we want <b>to</b> distribute <b>to</b> this <Link to="validator#0x3_validator">validator</Link>.
        <b>let</b> planned = divide_and_round_up(remaining_power, len - i);
        // target is the targeting power this <Link to="validator#0x3_validator">validator</Link> will reach, capped by threshold.
        <b>let</b> target = <Link to="../iota-framework/math#0x2_math_min">math::min</Link>(threshold, v.<Link to="voting_power#0x3_voting_power">voting_power</Link> + planned);
        // actual is the actual amount of power we will be distributing <b>to</b> this <Link to="validator#0x3_validator">validator</Link>.
        <b>let</b> actual = <Link to="../iota-framework/math#0x2_math_min">math::min</Link>(remaining_power, target - v.<Link to="voting_power#0x3_voting_power">voting_power</Link>);
        v.<Link to="voting_power#0x3_voting_power">voting_power</Link> = v.<Link to="voting_power#0x3_voting_power">voting_power</Link> + actual;
        <b>assert</b>!(v.<Link to="voting_power#0x3_voting_power">voting_power</Link> &lt;= threshold, <Link to="voting_power#0x3_voting_power_EVotingPowerOverThreshold">EVotingPowerOverThreshold</Link>);
        remaining_power = remaining_power - actual;
        i = i + 1;
    };
    <b>assert</b>!(remaining_power == 0, <Link to="voting_power#0x3_voting_power_ETotalPowerMismatch">ETotalPowerMismatch</Link>);
}
</code></pre>



</details>

<Link id="0x3_voting_power_update_voting_power"></Link>

## Function `update_voting_power`

Update validators with the decided voting power.


<pre><code>
<b>fun</b> <Link to="voting_power#0x3_voting_power_update_voting_power">update_voting_power</Link>(validators: &<b>mut</b> <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;, info_list: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="voting_power#0x3_voting_power_VotingPowerInfoV2">voting_power::VotingPowerInfoV2</Link>&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="voting_power#0x3_voting_power_update_voting_power">update_voting_power</Link>(validators: &<b>mut</b> <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;, <b>mut</b> info_list: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="voting_power#0x3_voting_power_VotingPowerInfoV2">VotingPowerInfoV2</Link>&gt;) \{
    <b>while</b> (!info_list.is_empty()) \{
        <b>let</b> <Link to="voting_power#0x3_voting_power_VotingPowerInfoV2">VotingPowerInfoV2</Link> \{
            validator_index,
            <Link to="voting_power#0x3_voting_power">voting_power</Link>,
            stake: _,
        } = info_list.pop_back();
        <b>let</b> v = &<b>mut</b> validators[validator_index];
        v.<Link to="voting_power#0x3_voting_power_set_voting_power">set_voting_power</Link>(<Link to="voting_power#0x3_voting_power">voting_power</Link>);
    };
    info_list.destroy_empty();
}
</code></pre>



</details>

<Link id="0x3_voting_power_check_invariants"></Link>

## Function `check_invariants`

Check a few invariants that must hold after setting the voting power.


<pre><code>
<b>fun</b> <Link to="voting_power#0x3_voting_power_check_invariants">check_invariants</Link>(v: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="voting_power#0x3_voting_power_check_invariants">check_invariants</Link>(v: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;) \{
    // First check that the total voting power must be <Link to="voting_power#0x3_voting_power_TOTAL_VOTING_POWER">TOTAL_VOTING_POWER</Link>.
    <b>let</b> <b>mut</b> i = 0;
    <b>let</b> len = v.length();
    <b>let</b> <b>mut</b> total = 0;
    <b>while</b> (i &lt; len) \{
        <b>let</b> <Link to="voting_power#0x3_voting_power">voting_power</Link> = v[i].<Link to="voting_power#0x3_voting_power">voting_power</Link>();
        <b>assert</b>!(<Link to="voting_power#0x3_voting_power">voting_power</Link> &gt; 0, <Link to="voting_power#0x3_voting_power_EInvalidVotingPower">EInvalidVotingPower</Link>);
        total = total + <Link to="voting_power#0x3_voting_power">voting_power</Link>;
        i = i + 1;
    };
    <b>assert</b>!(total == <Link to="voting_power#0x3_voting_power_TOTAL_VOTING_POWER">TOTAL_VOTING_POWER</Link>, <Link to="voting_power#0x3_voting_power_ETotalPowerMismatch">ETotalPowerMismatch</Link>);

    // Second check that <b>if</b> <Link to="validator#0x3_validator">validator</Link> A's stake is larger than B's stake, A's voting power must be no less
    // than B's voting power; similarly, <b>if</b> A's stake is less than B's stake, A's voting power must be no larger
    // than B's voting power.
    <b>let</b> <b>mut</b> a = 0;
    <b>while</b> (a &lt; len) \{
        <b>let</b> <b>mut</b> b = a + 1;
        <b>while</b> (b &lt; len) \{
            <b>let</b> validator_a = &v[a];
            <b>let</b> validator_b = &v[b];
            <b>let</b> stake_a = validator_a.<Link to="voting_power#0x3_voting_power_total_stake">total_stake</Link>();
            <b>let</b> stake_b = validator_b.<Link to="voting_power#0x3_voting_power_total_stake">total_stake</Link>();
            <b>let</b> power_a = validator_a.<Link to="voting_power#0x3_voting_power">voting_power</Link>();
            <b>let</b> power_b = validator_b.<Link to="voting_power#0x3_voting_power">voting_power</Link>();
            <b>if</b> (stake_a &gt; stake_b) \{
                <b>assert</b>!(power_a &gt;= power_b, <Link to="voting_power#0x3_voting_power_ERelativePowerMismatch">ERelativePowerMismatch</Link>);
            };
            <b>if</b> (stake_a &lt; stake_b) \{
                <b>assert</b>!(power_a &lt;= power_b, <Link to="voting_power#0x3_voting_power_ERelativePowerMismatch">ERelativePowerMismatch</Link>);
            };
            b = b + 1;
        };
        a = a + 1;
    }
}
</code></pre>



</details>

<Link id="0x3_voting_power_total_voting_power"></Link>

## Function `total_voting_power`

Return the (constant) total voting power


<pre><code>
<b>public</b> <b>fun</b> <Link to="voting_power#0x3_voting_power_total_voting_power">total_voting_power</Link>(): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="voting_power#0x3_voting_power_total_voting_power">total_voting_power</Link>(): u64 \{
    <Link to="voting_power#0x3_voting_power_TOTAL_VOTING_POWER">TOTAL_VOTING_POWER</Link>
}
</code></pre>



</details>

<Link id="0x3_voting_power_quorum_threshold"></Link>

## Function `quorum_threshold`

Return the (constant) quorum threshold


<pre><code>
<b>public</b> <b>fun</b> <Link to="voting_power#0x3_voting_power_quorum_threshold">quorum_threshold</Link>(): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="voting_power#0x3_voting_power_quorum_threshold">quorum_threshold</Link>(): u64 \{
    <Link to="voting_power#0x3_voting_power_QUORUM_THRESHOLD">QUORUM_THRESHOLD</Link>
}
</code></pre>



</details>
